#+Author: Avinash Malik
#+Email: avinash.malik@auckland.ac.nz
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t
#+OPTIONS: c:nil creator:comment d:(not "LOGBOOK") date:t e:t email:t
#+OPTIONS: f:t inline:nil num:nil p:nil pri:nil stat:nil tags:t tasks:nil tex:t
#+OPTIONS: timestamp:nil toc:t todo:nil |:t reveal_slide_number:nil org-html-indent:nil
#+DESCRIPTION:
#+EXCLUDE_TAGS: noexport
#+KEYWORDS:
#+LANGUAGE: en
#+Title: Time tide Programming Language
#+OPTIONS: html-style:nil
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/search.css"/>

#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/search.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>

#+MACRO: enable-search #+HTML_HEAD: <script type="text/javascript">enableSearch();</script>
#+MACRO: disable-search #+HTML_HEAD: <script type="text/javascript">disableSearch();</script>
#+MACRO: set-search-limit #+HTML_HEAD: <script type="text/javascript">setSearchLimit($1);</script>

* Time tide is a new programming language
  1. It allows building finite state machines.
  2. It allows developing synchronous concurrent programs.
  3. It allows for shared memory or distributed memory concurrency.
  4. The compiler produces efficient C++ code, which allows for easy
     interaction with native code and deployment on embedded platforms.
     
** Requirements when reading this document
  1. The reader is expected to have knowledge of:
     + Synchronous programming principles
     + Good knowledge of C/C++ including template meta-programming
  2. Please read the comments in the code snippet along with the text in
     this document.
  3. Time tide language and tool suite is a work in progress -- expect
     bugs and things to change daily
  4. Please file bug reports on github repository with code snippets
     when things do not work.

* Installing the Time tide compiler(s)
  1. Time tide uses multiple compiler tool chains.
  2. You are expected to have installed C++ compilers with support for
     at least C++-20 standard.
  3. Pull the Time tide compiler from:
     https://github.com/PRETgroup/timetide
  4. Install the Ocaml programming language compiler from here:
     https://ocaml.org/install#linux_mac_bsd
  5. Install dune with command ~opam install dune~
  6. Now go to the timetide directory and do command ~dune build~
  7. It will *not* compile and list the missing libraries.
  8. You will need to manually install the libraries like so: ~opam install <lib-name>~
  9. You will need to install the following libraries:
     ~pretty_expressive~
     ~ppx_deriving~
     ~ppx_sexp_conv~
     ~sexplib~
     ~base~
  10. Once all the libraries are installed you should be able to build
      the compiler using ~dune build~ in the timetide directory.
  11. Download and install the Rust programming language compiler from:
      [[https://rustlang.org][Rust]]
  12. Pull the Sysrust intermediate language compiler from:
      https://github.com/amal029/sysrust
  13. Go inside the Sysrust compiler directory and run: ~make br~
  14. Download and pull the Time tide example directory from:
      https://github.com/PRETgroup/Timetide_tests
  15. Go inside the ~Timetide_tests~ directory and run the following
      command:
      #+begin_src bash
	COMPILE_SWITCH=sysrs FNAME="abro" SYSRUST_DIR=<path-of-sysrust-compiler-dir> \
			     TIMETIDE_DIR=<path-of-timetide-compiler-dir> make cleanall
      #+end_src
  16. In the above command replace the ~<path-of-sysrust-compiler-dir>~
      with where you have downloaded the individual timetide and sysrust
      compilers.
  17. Now run the command:
      #+begin_src bash
	COMPILE_SWITCH=sysrs FNAME="abro" \
			     SYSRUST_DIR=<path-of-sysrust-compiler-dir> \
			     TIMETIDE_DIR=<path-of-timetide-compiler-dir> compilers
      #+end_src
      - This will build all the compilers.

* Compiling first example program

We will use the ~abro.tt~ program in ~Timetide_tests~ directory as our
first program.

#+begin_src C -n
  main() {
    int channel A delay 1;
    int channel B delay 1;
    int channel R delay 2;
    int channel O delay 1;
    {
      for (int i:1:99) {
        abort(R) {		/* preemption when channel has data */
  	/* Wait for A and B in parallel */
  	{run waitA(A);}<>{run waitB(B);};
  	send O(100);		/* send O once both are received */
  	/* abort when R is present and restart */
  	task(period=1,duration=0,offset=0){;} /* halt */
        }
      } /* loop back */
    }<> /* synchronous parallel concurrency */
      {/*The environment*/
        {send A(1);}<>{send B(1);};
      }
  };
  /* Other functions/reactions being used inside main */
  waitA(input int A) {abort(A) {task(period=1,duration=0,offset=0){;}}};
  waitB(input int B) {abort(B) {task(period=1,duration=0,offset=0){;}}}
#+end_src

1. The code above is a *shared* memory synchronous program.
2. The program' entry point is ~main~.
3. The program has three modules/functions/reactions: ~waitA~,
   ~waitB~, and ~main~.
4. The ~main~ function waits for some data to be available on
   ~channels~ A and B in synchronous parallel.
5. Once the channel data is received; ~main~ sends data on channel O.
6. If during the process of waiting if any data is available on
   channel R, ~main~ pre-empts waiting for A and B and the program is
   reset.
7. Channels are typed and have an associated delay.
8. In the ~abro.tt~ program sending data in channel A or B makes it
   available after a single so called ~tick~.
9. Sending data in channel R makes it available after two ticks.
10. The concept of a ~tick~ is central to programming in Time tide.
11. Tick is the synchronous (logical) clock running the whole program.


** Compiling the abro (shared memory) program
1. Run the command:
   #+begin_src bash
     COMPILE_SWITCH=sysrs FNAME="abro" \
     		     SYSRUST_DIR=<path-of-sysrust-compiler-dir> \
     		     TIMETIDE_DIR=<path-of-timetide-compiler-dir> make	
   #+end_src
   - This will produce three files ~abro.sysrs~ and ~abro.cpp~ and
     ~abro.h~.
2. The file ~abro.sysrs~ is the intermediate representation of the
   ~abro.tt~ program in a synchronous format.
3. Files ~abro.cpp~ and ~abro.h~ are the generated C++ and header,
   respectively.
4. The code snippet below shows the part of the generated ~main~
   function. The generated ~main~ function is in namespace ~abro~ --
   always the name of the ~.tt~ file.
5. You need to now write a ~main.cpp~ file that provides the input
   and output functions.
   #+begin_src C++ -n -r
     namespace abro {
       //....
       int main(void) {
         read_inputs();		// provide this function
         //...
         write_outputs();		// provide this function
         pre_eq_curr();
         reset_curr();
         return 0;
       }
     }
   #+end_src
6. The example ~main.cpp~ file is below. The file is available in
   ~Timetide_tests~ directory to modify.
   #+begin_src C++ -n -r
     #include "abro.h"
     #include <cassert>
     #include <iostream>
     int mtick() {
       char b = '\0';
       int k = scanf("%c", &b);
       return b;
     }
     // In this case there are no inputs and outputs to abro.tt
     void abro::read_inputs() {}
     void abro::write_outputs() {}

     // The main function
     int main(void) {
       while (1) {
         // Run the abro program
         abro::main();
         // Then we are done with the tick.
         if (mtick() == 'd')
           break;
       }
       return 0;
     }
   #+end_src

7. Once we have the ~main.cpp~ file we can compile the ~abro~ example
   to a binary using the command:
   #+begin_src bash
     COMPILE_SWITCH=sysrs FNAME="abro" \
     		     SYSRUST_DIR=<path-of-sysrust-compiler-dir> \
     		     TIMETIDE_DIR=<path-of-timetide-compiler-dir> EXTRA_FLAGS="-DDEBUG" exe
   #+end_src
   - Notice the ~-DDEBUG~ macro being provided.

8. We can finally run the program using the command:
   #+begin_src bash
     COMPILE_SWITCH=sysrs FNAME="abro" \
		    SYSRUST_DIR=<path-of-sysrust-compiler-dir> \
		    TIMETIDE_DIR=<path-of-timetide-compiler-dir> EXTRA_FLAGS="-DDEBUG" run
   #+end_src

** Compiling the abro example (distributed memory) program
The primary idea is to divide the ~abro~ program into two parts: (a)
~abro_sys.tt~, which captures the system waiting for the data to
arrive from input channels, and (b) the environment ~abro_env.tt~
that produces the inputs for the system.

1. In this case we will write two different modules/files
   ~abro_sys.tt~ and ~abro_env.tt~. These individual modules are
   presented below:

   #+begin_src C -n -r
     /* abro_sys.tt */
     main(input int A, input int B, input int R, output int O) {
       for (int i:1:99) {
	 abort(R) {
	   /* Wait for A and B in parallel */
	   {run waitA(A);}<>{run waitB(B);};
	   send O(100);		/* send O once both are received */
	   /* abort when R is present and restart */
	   task(period=1,duration=0,offset=0){;} /* halt */
	 }
       } /* loop back */
     };
     waitA(input int A) {abort(A) {task(period=1,duration=0,offset=0){;}}};
     waitB(input int B) {abort(B) {task(period=1,duration=0,offset=0){;}}}
   #+end_src

   #+begin_src C -n -r
     /* abro_env.tt */
     main(output int A, output int B, output int R) {
       {send A(1);}<>{send B(1);};
       send R(1);
     }
   #+end_src

2. Important point to notice:
   + Each of these modules are written in their individual files
      ~abro_sys.tt~ and ~abro_env.tt~.
   + Each module has an individual ~main~ function/reaction.
   + The ~main~ function takes inputs and outputs as required.

3. In order to compile these individual modules we execute the
   following command:
   #+begin_src bash
     COMPILE_SWITCH=sysrs FNAME="abro_sys abro_env" \
			  SYSRUST_DIR=<path-of-sysrust-compiler-dir> \
			  TIMETIDE_DIR=<path-of-timetide-compiler-dir> make \
			  EXTRA_FLAGS="-DDEBUG"
   #+end_src
   - Notice that we specify the individual module names in ~FNAME~
     environment variable for compiling both modules together.

4. Upon success we get files: ~abro_sys.sysrs~, ~abro_env.sysrs~,
   ~abro_sys.cpp~, ~abro_sys.h~, ~abro_env.cpp~, and finally
   ~abro_env.h~.

5. We now need to provide the input and output read write functions:
   ~abro_sys::read_inputs~, ~abro_sys::write_outputs~,
   ~abro_env::read_inputs~, and ~abro_env::write_outputs~ in the
   ~main.cpp~ file for these individual modules to communicate with
   each other.

6. These functions are presented below:

   - The ~abro_env::write_outputs~ function:
     #+begin_src C++ -n -r
       // This function serializes and then send the data from output port to
       // the input port.
       template <typename In, typename Out, typename Q>
       void In2Out(In *in, Out *out, Q *q) {Qpush(q, (void *)in, out);} (ref:queue)
       // We always write the current value from one to the previous value of
       // the next.
       void abro_env::write_outputs() { (ref:writeo)
	 // Then we write the outputs for the tick done.
	 In2Out(abro_env::A_curr_ptr, abro_sys::A_prev_ptr, abro_sys::qA_ptr);
	 In2Out(abro_env::B_curr_ptr, abro_sys::B_prev_ptr, abro_sys::qB_ptr);
	 In2Out(abro_env::R_curr_ptr, abro_sys::R_prev_ptr, abro_sys::qR_ptr);
       }
     #+end_src
   - Function ~abro_env::write_outputs~ (Line [[(writeo)]]) passes the
     outputs from module ~abro_env~ to module ~abro_sys~.
   - This function *binds* the output from ~abro_env~ module to
     ~abro_sys~ module.
   - The output channel ~A~ in module ~abro_env~ (specifically
     ~abro_env::A_curr_ptr~) is bound to input channel ~A~ in module
     ~abro_sys~ (specifically ~abro_env::A_prev_ptr~). Same for channels
     ~B~ and ~R~.
   - Function ~In2Out~ achieves this binding via queue on the
     receiving side -- in this case module ~abro_sys~.
   - The third argument in function ~In2Out~ (Line [[(queue)]]) is this
     receiving queue for each channel.
   - The size of the queue is determined by the delay $\delta$
     connecting the channels, and is determined by the system
     designer.
   - The ~Qpush~ function (Line [[(queue)]]) is provided in the library
     (which we will see later) for pushing into the queue of the
     receiver.

   - The ~abro_env::read_inputs~ function:
     #+begin_src C++
       // No inputs needed, because main module in abro_env.tt has no inputs
       void abro_env::read_inputs() {}
     #+end_src

7. The channels being used to connect the two modules along with the
   queue functions are provided in files:
   - ~abro_env.h~, ~abro_sys.h~, ~includes/lib.h~, and
     ~includes/mQueue.h~ in the ~Timetide_tests~ directory.
   - The ~abro_env.h~ and ~abro_sys.h~ headers are generated by the
     compiler and are specific to the modules being compiled.
   - The headers in the ~includes~ folder form the part of the
     library used to compile distributed memory systems.

8. The important parts of the generated ~abro_env.h~ header is shown
   below:
   #+begin_src C++ -n -r
     namespace abro_env {
       // ....
       struct signal_A;
       // The below are the opaque pointers used for communication
       extern signal_A *A_curr_ptr, *A_prev_ptr;
       // A_curr_ptr is a pointer to status/value of channel A for current tick.
       // A_prev_ptr is a pointer to status/value of channel A for previous tick.
       struct signal_B;
       extern signal_B *B_curr_ptr, *B_prev_ptr;

       struct signal_R;
       extern signal_R *R_curr_ptr, *R_prev_ptr;

       // Templates for opaque channel pointers
       template <typename T> size_t get_sizeof_value(T *);
       template <typename T> size_t get_sizeof_status(T *);
       template <typename T> bool get_status(T *);
       template <typename T> void get_value(void *dest, T *signal);
       template <typename T> void set_status(T *signal, unsigned char v);
       template <typename T> void set_value(T *signal, void *src);
       template <typename T, typename S> void Qpush(T *, void *, S *);
       template <typename T, typename S> size_t Qpull(T *, S *);
       void write_outputs();
       void read_inputs();
     }
   #+end_src

9. The implementation of these header functions is provided in
   ~includes/lib.h~ and is provided below:
   #+begin_src C++ -n
     template <typename T>
     concept has_status = requires(T* t) {
       {t->status};
     };

     template <typename T>
     concept has_value = requires(T *t) {
       { t->value };
     };

     template <typename T>
     requires has_value<T>
     constexpr size_t get_sizeof_value(T *obj) {
       return sizeof(obj->value);
     }

     template <typename T>
     requires has_status<T>
     constexpr size_t get_sizeof_status(T *obj) {
       return sizeof(obj->status);
     }

     template <typename T>
     requires has_status<T>
     bool get_status(T *obj) { return obj->status; }

     template <typename T>
     requires has_value<T>
     void get_value(void *dest, T *obj) {
       memcpy(dest, &(obj->value), get_sizeof_value(obj));
     }

     template <typename T>
     requires has_status<T>
     void set_status(T *obj, unsigned char v) {
       memcpy(&(obj->status), &v, get_sizeof_status(obj));
     }

     template <typename T>
     requires has_value<T>
     void set_value(T *obj, void *src) {
       memcpy(&(obj->value), src, get_sizeof_value(obj));
     }

     template <typename Q, typename S>
     requires has_status<S> && has_value<S>
     void Qpush(Q *q, void *src, S *s) {
       constexpr std::size_t size = sizeof(s->status) + sizeof(s->value);
       std::size_t size_status = get_sizeof_status(static_cast<S *>(src));
       // This array is stack allocated
       std::array<unsigned char, size> arr{0};
       memcpy(arr.data(), &(static_cast<S *>(src))->status, size_status);
       memcpy(arr.data() + size_status, &(static_cast<S *>(src))->value, size - size_status);
       q->v->push(std::move(arr));
     }

     template <typename Q, typename S>
     requires has_status<S> && has_value<S>
     std::size_t Qpull(Q *q, S *s) {
       constexpr std::size_t size = sizeof(s->status) + sizeof(s->value);
       using at = std::array<unsigned char, size>;
       at *res = q->v->front(); // the pointer to the top of the queue.
       s->status = (*res)[0]; // the first value in the returned array
                              // pointer
       set_value(s, &(*res)[1]);
       q->v->pop();
       return size;
     }
   #+end_src

10. The templated library function implementations are specialised
    for each channel in generated C++ code from the Time tide
    modules. Example shown below from ~abro_env.cpp~:
    #+begin_src C++ -n -r
      namespace abro_env {
        //...
        #include "lib.h"

        // Sig decls
        typedef struct signal_A {
          int value = 0;
          bool status = false;
          // We should never need the combinator operator
          std::plus<int> op{};
          // tag is for fresh value updates
          bool tag = false;
        } signal_A;
        signal_A A_curr, A_prev;
        signal_A *A_curr_ptr = &A_curr;
        signal_A *A_prev_ptr = &A_prev;
        // Below are template specilisations for working with channel A
        template size_t get_sizeof_value(signal_A *); (ref:start)
        template size_t get_sizeof_status(signal_A *);
        template bool get_status(signal_A *);
        template void get_value(void *, signal_A *);
        template void set_value(signal_A *, void *);
        template void set_status(signal_A *, unsigned char v); (ref:end)
        // ......
      }
    #+end_src

    - Notice the template specialisation from (Line [[(start)]] -- Line [[(end)]])

11. Similarly, the receiving Queue' opaque queue pointers (e.g.,
    ~abro_sys::qA_ptr~) are declared and the ~Qpush~ and ~Qpull~
    template functions specialised in the generated C++ files. See
    below for a snippet of the generated ~abro_sys.cpp~:
    #+begin_src C++ -n
      #include "mQueue.h"
      namespace abro_sys {
        // ....
      #include "lib.h"
        // ......
        // mQueue is defined in includes/mQueue.h
        using qA_t = mQueue<std::array<unsigned char, sizeof(A_prev_ptr->status) +
      				 sizeof(A_prev_ptr->value)>>;
        // mQueue.h provides a lockfree queue implementation, so it can be used with many threads
        qA_t qA(A_DELAY, {});
        struct QA {
          qA_t *v;
          QA(qA_t *p) : v(p) {}
        };
        QA qA_var(&qA);
        QA *qA_ptr = &qA_var;
        template void Qpush(QA *, void *, signal_A *); // template specilisation
        template size_t Qpull(QA *, signal_A *);	 // template specilisation
        // ....
      }
    #+end_src

12. *Never* include standard library headers in ~includes/lib.h~,
    because it is included in the module' namespace.

13. The delay $\delta$ determining the size of the queues is defined
    in file ~delays.cpp~. For the current example the code is shown
    below:
    #+begin_src C++ -n
      #include "abro_sys.h"
      int abro_sys::A_DELAY = 4;	// size of queue connecting channel A
      int abro_sys::B_DELAY = 2;	// size of queue connecting channel B
      int abro_sys::R_DELAY = 5;	// size of queue connecting channel R
    #+end_src

14. Finally, we can now write the main function that runs the two
    modules. This function is written in ~main.cpp~ and is shown
    below:
    #+begin_src C++ -n -r
      #include "abro_env.h"
      #include "abro_sys.h"
      #include <atomic>
      #include <cassert>
      #include <iostream>
      #include <thread>
      void abro_run(std::atomic<int> &&barrier = 0) {
        std::cout << "running two threads\n";
        auto env = std::thread([&barrier]() { (ref:thread1)
          while (barrier != 1) {
            std::this_thread::yield();
          }
          barrier--;
          // First we read from the buffer for all inputs
          std::cout << "Running the abro env \n";
          abro_env::main();
          std::cout << "Done running the abro env\n";
        });

        auto sys = std::thread([&barrier]() { (ref:thread2)
          while (barrier != 2) {
            std::this_thread::yield();
          }
          barrier--;
          std::cout << "Running the abro sys\n";
          abro_sys::main();
          std::cout << "Done running the abro sys\n";
        });
        // XXX: you can change this to change the order of execution.
        // barrier = 2, makes sys run first.
        // barrier = 1, makes the env run first.
        // think of barrier as a token that is passed to threads to make then
        // execute an LSN.
        barrier = 2;
        while (barrier != 0) (ref:barrier)
          ; // spin until both the modules/threads are done -- the barrier
        env.join();
        sys.join();
      }
      int main(void) {
        while (1) {
          abro_run();
          // Then we are done with the tick.
          if (mtick() == 'd')
            break;
        }
        return 0;
      }
    #+end_src
    + Notice that we are using threads to run the two modules.
    + The first thread runs ~abro_env::main~ (Line [[(thread1)]])
    + The second thread runs ~abro_sys::main~ (Line [[(thread2)]])
    + The two threads execute one tick each before reaching a barrier
      (Line [[(barrier)]])
    + It is *essential* that all modules in the Time tide program
      execute using barriers, because they all need to be
      synchronised.
    + Every module reaching the barrier indicates the end of a global
      tick.

15. Once all the required files and functions are in place we can
    generate the binary to execute using the command:
    #+begin_src bash
      COMPILE_SWITCH=sysrs FNAME="abro_sys abro_env" \
			  SYSRUST_DIR=<path-of-sysrust-compiler-dir> \
			  TIMETIDE_DIR=<path-of-timetide-compiler-dir> make \
			  EXTRA_FLAGS="-DDEBUG delays.cpp" exe	 
    #+end_src

16. We can then run the program like so:
    #+begin_src bash
      COMPILE_SWITCH=sysrs FNAME="abro_sys abro_env" \
			  SYSRUST_DIR=<path-of-sysrust-compiler-dir> \
			  TIMETIDE_DIR=<path-of-timetide-compiler-dir> make \
			  EXTRA_FLAGS="-DDEBUG delays.cpp" run	 
    #+end_src

17. One needs to write a new library header/C++ file to send data
    across network leveraging ~includes/lib.h~. This can be via
    sockets, UART, etc.

18. When the modules are implemented on physically different
    machines, make sure that modules still execute using barrier
    synchronisation.

** Visual Studio Code Time tide syntax highlighter and formatter 
# Image with caption
#+CAPTION: Time tide syntax highlighter and formatter on the VSCode Extensions page
#+NAME: fig:compilation
[[./images/timetide_dsl_formatter.png]]

We currently have a syntax highlighter and formatter for *Visual Studio Code* and any other editors, like *Cursor*, that can access Visual Studio Code extensions. The extension can be installed as follows.

1. Please go the Extensions tab in Visual Studio Code (VS Code) or other editors with access to  VS Code Extensions.
2. Search Timetide DSL.
3. Click on install. Please ensure that the extension page looks like the one shown in the figure above.

*Note:* The syntax highligter and formatter is currently under development and may have some issues. Please report your issues at https://github.com/amal029/amal029.github.io.



* The Time tide language

** Types and variables

*** Primitive types
  We only support three signed primitive types listed below
#+begin_src C -n
  int	a;			/* This is a comment (int is 4 bytes) */
  char	a;			/* char is  1 byte */
  float	a;			/* Float is 4 bytes */
#+end_src

*** User defined structures
   User defined types follows the same convention as =C=. However, no
   pointers are allowed. Examples follow:
#+begin_src C -n
  struct Y { int a; float u;};	/* Structure (type Y) with field varibles a and u */
  struct X {
    int yy;			/* varible yy of type int */
    struct Y g;			/* variable g of type struct Y */
  }
  /* Since there are no pointers, one cannot define self refrential structures */
  struct X {
    struct X *m;			/* not allowed */
  }
#+end_src

*** Array types
    Arrays are ~similar~ (not the same) to those in =C=.
    Multidimensional arrays are supported. Example follows:
    #+begin_src C -n
      const int[4] X = {0, 0, 0, 0};	/* constant array, notice it is int[4]  not int X[4]*/
      const int[2][3] Y = {{0, 0, 0}, {0, 0, 0}} /* 2 x 3 constant array Y -- multidimensional */
    #+end_src

*** Channels
    1. Channels are specific to Time tide and do not exist in ~C~.
    2. Channels carry data.
    3. Channels also have an associated delay $\delta$.
    4. Channels can be of any primitive, user defined, or array type.
    5. Channel status and values are set using =send= (Line [[(send)]])
    6. Channel status is read using the name of the channel (Line
       [[(status)]])
    7. Channel value is read using =?<channel-name>= (Line [[(val)]])
    8. Examples follow:
    #+begin_src C -n -r
      int channel K delay 3;		/* Channel K of type int with delay 3 */
      struct Y channel C delay 2;	/* Channel C of type struct Y with delay 2 */
      int[100] channel M delay 1;	/* Channel M of type int[100] with delay 1*/

      /* TODO: Such bunching of channels  are not yet supported */
      struct Y[100] channel M[100] delay 7; /* 100 channel M[0]...M[99] each of
          					 type struct Y[100] with delay 7*/
      send K(10);			/* Will be available at receiver after 3 logical ticks */ (ref:send)
      if (K) { (ref:status)
        mut int uu = 0 {		/* Definig a mutable integer uu, scope starts at {*/
         uu = ?K 		/* Updating the value of uu by reading the value of channel K */(ref:val)
        }			/* scope of variable uu ends */
        /* body... */
       }
    #+end_src

** Operators and expressions in Time tide

*** Operators in Time tide

#+begin_src C -n
  a + b;				/* addition */
  a - b;				/* subtraction */
  a % b;				/* Modulus  */
  a * b;				/* Multiply */
  a / b;				/* Divide */
  a >> b;				/* Right shift logical */
  a << b;				/* Logical left shift */
  a > b;				/* Logical greater than */
  a < b;				/* Logical less than */
  a >= b;				/* Logical greater than equal */
  a <= b;				/* Logical less than equal */
  a == b;				/* Logical equality comparison */
  a != b;				/* Logical not equal to comparison */
  a ^^ b;				/* a to the power of b */
#+end_src
  + The above operators are defined on primitive types only.
    
  
*** Expressions in Time tide

    + Time tide supports the usual expressions as in =C=.
    
    #+begin_src C -n -r
      a + b - c			/* left to right precedence */
      (a + b) * c			/* Bracket has higher precedence */
      a + b * c			/* Multiply has higher precedence */
      a * b / f			/* Left to right precedence */
      (a == b) && (b != c)		/* Logical and expression */
      (a == 1) || (b == 1)		/* logical or */
      !(a == 0)			/* logical not */
      (int)1.0			/* casting C style */
        
      channel int K delay 1;			/* int type channel */
      channel int I1 delay 1;			/* int type channel */
      extern f(1.0+(float)?K * (float)?I1); /* calling an external C function */ (ref:ext)

      struct X{int a;};
      struct Y{
        float h;
        struct X xx;
      }
      /* Let yy be a variable of type struct Y */
        y.h = (float)7;			/* assigning to field h */ (ref:struct1)
        y.xx = {(int)8.5};			/* assigned to field xx of type struct X */
      y.xx.a = (int)8.5;			/* Not allowed */ (ref:struct3)
      struct X {
        float x;
        int[2] uuar;	/* Currently arrays inside structs are not supported */ (ref:structarr)
      };
    #+end_src

    * =extern= function calls are expressions (not statements)
    * Might need to cast the output or arguments to correct type in
      =extern= function calls (Line [[(ext)]])
    * Only one level of =struct= fields can be accessed right now (Line
      [[(struct1)]] -- Line [[(struct3)]]) -- will change in the future
    * Arrays inside =struct= are currently not supported -- will change in
      the future (Line [[(structarr)]]).
    * A more detailed example of calling =extern C= functions is provided
      below:
      #+begin_src C
	/* Intelligent Driver Model car system with external C function call */
	extern { 			/* extern function declaration */
	  /* The below is the type signature of the function defined in C */
	  struct IDMState idm_run(float, float, float, float, float);
	};

	/* Intelligent Driver Model car state */
	struct IDMState {
	  float position;
	  float velocity;
	  float acceleration;
	  float gap;
	  float lead_position;
	  float lead_velocity;
	};

	/* Intelligent Driver Model car system main function/module */
	main(input float lead_position, input float lead_velocity, 
	     output float car_position, output float car_velocity,
	     output float car_acceleration)
	/* The arguments to main are the I/O to this module */
	{
	  const float dt = 0.1; /* Time step -- constant variable */
	  /* Initial car state -- mutable variable */
	  mut struct IDMState car = {0.0, 20.0, 0.0, 0.0, 0.0, 0.0} { /* mutable variable */
	    /* Wait for fresh lead vehicle data from the input channels */
	    if (lead_position && lead_velocity) {
	      /* Get current lead vehicle state */
	      mut float current_lead_pos = 0.0 { /* mutable variable */
		current_lead_pos = ?lead_position; /* update variable with value of channel */
		mut float current_lead_vel = 0.0 { /* mutable variable */
		  current_lead_vel = ?lead_velocity; /* update variable with value of channel */
		  /* Call external C IDM function and get struct result */
		  /* IDM returns IDMState struct with all updated values */
		  /* Run the idm_run function and return stating that it
		     succeeded. */
		  car =			/* extern call -- updating car variable*/
		  extern idm_run(dt, car.position,
				 car.velocity, current_lead_pos, current_lead_vel);
		}
	      }
	    }
	  }
	}
      #+end_src
    * Type of =extern= function declaration and call have to match, else
      an error will be raised by the compiler.
    * The types of arguments and return type have to match between the
      =extern= type signature declaration and its use.
    * =extern= functions are unique, i.e., there can only be one
      function =f= with a given signature. This is requirement of the
      =C= programming language.

** Statements

*** Variable declaration and updates
   1. There are two types of variables =const= and =mutable=.
   2. Constant variables cannot be modified.
   3. Mutable variables are like normal =C= style variables.
   4. Variables should always be initialised with literal constants (not
      expressions).
   5. Shadowing variable names is *not* allowed.
   6. Examples follow:
   #+begin_src C -n
     const int U11 = 1;		/* constant variabel U11 cannot change */
     const int T = 10;		/* constant variable T cannot change */
     mut float hh = 1.0 {
       /* ..... body/scope of mutable variable */
     } /* Mutable variable hh with its scope defined by {} */
     mut float f;			/* error, variable needs to be initialised */
     float f; 			/* error, do not know whether this is const or mutable */


     /* Define a structure */
     struct X {
       float x;			/* field x */
     };

     /* Define another structure */
     struct Y {
       int a;			/* field a */
       struct X m;			/* field m */
     };

     const int[2] U1 = {1, 2};	/* Constant array U1 of type int[2] with elements 1 and 2*/
     struct Y channel C delay 2;	/* Channel C of type struct Y with delay 2 */
     /* A mutable structure */
     mut struct Y y = {100, {9.6}} {
       y.a = U1[0];			/* Updating the field of y */
       /* Send on channel C */
       send C(y); 			/* Will be available at receiver after two global ticks */
     }
     const int HH = 100;
     mut int HH = 90 {
       /* body */
     } /* Such shadowing of variable name HH is *not* allowed */
   #+end_src

*** Conditionals
    1. Only ~if-else~ blocks are supported.
    2. The semantics are similar (not the same) as ~C~.
    3. Example follows:
       #+begin_src C -n
	 const int K1 = 0;
	 /* This is getting the value of the channel */
	 mut int U = 0 {
	   U = ?L;			/* get the value of channel */
	   if (?L == 1) {;}		/* check the value of the channel */
	   else {U = 100;}
	 }
	 if (L) {			/* check status of channel */
           task(period=1, duration=1, offset=0) {;}
         }
       #+end_src
    4. Major difference to ~C~
       - Checking *value* of variable/channel requires one to write:
	 #+begin_src C -n
	   if(<var-name> == <some-expression>){/*body*/}
	   if(<?channel-name> == <some-expression>){/*body*/}
	 #+end_src
       - Checking the *status* of the channel requires one to write:
	 #+begin_src C -n
	   if(<channel-name>) {/*body*/}
	 #+end_src
       - Expressions in conditionals for variables. Using name only
         implies checking channel status.

*** Loops

**** Sequential loops
    1. Sequential loops in Time tide are always bounded.
    2. Sequential loops are of two types:
       - Yielding, where every loop iteration produces results in
         completion of module' tick
       - Instantaneous, where the whole loop gets unrolled.
    3. Example of instantaneous loop follows:
       #+begin_src C -n
	 mut int[4] g = {0, 0, 0, 0} {	/* declare an array */
	   /* The below is an instantaneous loop */
	   for(int i : 0:4) {		/* Loop through the array */
	     g[i] = g[i] + i;		/* update the value of the array */
	   }
	 }
	 /* The above loop is equivalent to */
	 mut int[4] g = {0, 0, 0, 0} {	/* declare an array */
	   g[0] = g[0] + 0;		/* update the value of the array */
	   g[1] = g[1] + 1;		/* update the value of the array */
	   g[2] = g[2] + 2;		/* update the value of the array */
	   g[3] = g[3] + 3;		/* update the value of the array */
	 }
       #+end_src
       
    4. Example of yielding (non-instantaneous) loop follows:
       #+begin_src C -n
	 mut int[4] X = {0, 0, 0, 0} {	/* declare array X */
	   mut int v = 0 {		/* declare a mutable variable */
	     for(int i:0:4) {		/* Iterate through the loop */
	       /* Define a task, which performs its body every 1 logical tick */
	       task(period=1, duration=0, offset=0) {
	 	v = v + i;		/* increment v every tick */
	 	X[i] = v + i;		/* update X[i] every tick */
	       }				
	     }/* break once iterations are done */
	   }
	 }
       #+end_src
       
       + The above code will update the value of X' elements
         once/logical tick of the module.
       + This is different to instantaneous loop where all of X'
         elements get updated in the same logical tick of the module.

**** Parallel loops
   1. Parallel loops execute statement in synchronous parallel -- update
      values together.
   2. Parallel loops in Time tide are always bounded.
   3. Parallel loops are of two types:
      + Yielding, where every loop iteration produces results in
        completion of module' tick
      + Instantaneous, where the whole loop gets unrolled.
   4. Parallel loops should work on *disjoint* memory locations.
   5. Examples follow:
      #+begin_src C -n -r
	mut int[4] g = {0, 0, 0, 0} { 	/* start of a parallel loop */ (ref:pstart)
	    /* Instantaneous parallel loop */
	    par(int i : 0:4) {
		g[i] = g[i] + i;		/* working on disjoint memory */ (ref:pupdate)
	    } /* end of a parallel loop */ (ref:pend)
	}
	mut int[4] g = {0, 0, 0, 0} { 
	    /* Non instantaneous parallel loop */
	    par(int i : 0:4) {(ref:pstart2)
		task(period=1, duration=0, offset=0) { /* update g in parallel and complete tick */
		    g[i] = g[i] + i;		       /* working on disjoint memory */
		}
	    }(ref:pend2)
	}

	/* Incorrect parallel loop */
	mut int v1 = 0 { 
	    par(int j : 0:10) {(ref:pstart3)
		v1 = v1 + j;		/* updating the same location in parallel */
	    }
	}
	/* Incorrect parallel loop */
	int channel FH delay 1;
	mut int v1 = 0 {
	    par(int j : 0:10) { (ref:pstart4)
		send FH(10);		/* sending in parallel is not allowed */
	    }
	}

	/* Potentially incorrect parallel loop */
	mut int[4] g = {0, 0, 0, 0} {
	  par(int i : 0:4) { (ref:pstart5)
	   g[i] = g[i-1] + i; /* Loop carried dependency */ (ref:pupdate2)
	  }
	}
      #+end_src

      + Line [[(pupdate)]], in the code above, updates different memory
	locations of array =g= in parallel.
      + Loop on Line [[(pstart)]] runs instantaneously without generating a
        logical tick.
      + Loop on Line [[(pstart2)]] updates the disjoint memory locations and
        then completes a logical tick.
      + Loop on Line [[(pstart3)]] is incorrect since it is updating the
        same memory location =v1= in parallel.
      + Loop on Line [[(pstart4)]] is incorrect since it is sending on the
        same channel =FH= in parallel.
      + Loop on Line [[(pstart5)]] is _potentially_ incorrect, because the
        loop carried dependency on Line [[(pupdate2)]]. It is unclear what
        the programmer intends.
      + Incorrect loops, writing to the same memory location, raise a
        compiler warning.
      + Incorrect loops, sending on channels in parallel, raise a
        compiler error.
      + Compiler warnings are overestimates, not exact.
	
*** The Task construct
     1. Tasks are the primary construct to introduce state (tick) in a
        Time tide program.
     2. Tasks have a =period=, which determines how often the body of
        the task ticks.
     3. Tasks have a =duration=, which determines how many ticks does
        the body of the task takes.
     4. Tasks have an =offset=, which determines a starting offset (in
        number of logical ticks) the body of the task.
     5. Tasks *cannot* be nested.
     6. Task bodies have to be instantaneous.
     7. Task =period= has to be greater than or equal to the
        =duration= + =offset= specified.
     8. The channel delays interact in complex ways with the task
        =period=, please follow compiler output when sending on channels
        inside tasks.
     9. Examples follow:
	#+begin_src C -n
	  motorA (output int MOTOR_A_SPEED,
	  	input int LIGHT_LOW_1,
	  	input int LIGHT_HIGH_1) {
	    for(int i: 0:99) {
	      send MOTOR_A_SPEED(100);
	      abort(LIGHT_LOW_1) {		    /* preempt when LIGHT_LOW_1 channel status is true */
	        task(period=1,duration=0,offset=0){;} /* self loop on state */
	      }
	      send MOTOR_A_SPEED(20);
	      abort(LIGHT_HIGH_1) {		     /* preempt when LIGHT_HIGH_1 channel status is true */
	        task(period=1,duration=0,offset=0) {;} /* self loop on state */
	      }
	    }
	  };
	  int channel C delay 3;
	  /* Incorrect channel send, delay-1 != task' period */
	  task(period=3, duration=2, offset=1) {
	    send C(1);
	  } /* compiler will raise an error in the above case */

	  /* Incorrect task, because period is not >= duration + offset */
	  task(period=2, duration=2, offset=1) {
	    send C(1);
	  }
	#+end_src

*** The Abort construct
     1. =abort(logical-expression){/* body */}= is the way to preempt a halted system.
     2. Example follows:
	#+begin_src C -n
	  mut int yt = 100 {
	    /* We check for the value of channel C and status both*/
	    abort(?C == yt || C) {	     /* preempt when the logical expression is true */
	      task(period=2, duration=1, offset=1) {;} /* halted forever */
	    }
	    yt = yt + ?C;			/* make progress here only after preeemption */
	  }
	#+end_src

*** The Synchronous parallel construct
    1. ={/*thread body 1*/}<>{/*thread body 2*/}<>{/*thread body
       3*/}...= is the way to execute multiple bodies in parallel.
    2. All requirements of =par= loop also apply to synchronous
       parallel execution.
    3. Examples follow:
       #+begin_src C -n
	 h(input const int T, output int I, input int L)
	 {
	   /* const int U11 = 100; */
	   {run m(T, I);} <> {run m1(T, L);} /* m and m1 are some modules/functions */
	 };

	 /* Another example -- snippet from the abro example */
	 main() {
	   int channel A delay 1;
	   int channel B delay 1;
	   int channel R delay 2;
	   int channel O delay 1;
	   {
	     for (int i:1:99) {
	       abort(R) {
	 	/* Wait for A and B in parallel */
	 	{run waitA(A);}<>{run waitB(B);};
	 	send O(100);		/* send O once both are received */
	 	/* abort when R is present and restart */
	 	task(period=1,duration=0,offset=0){;} /* halt */
	       }
	     } /* loop back */
	   }<> /* synchronous parallel */
	     {/*The environment*/
	       {send A(1);}<>{send B(1);}; /* another sychronous parallel */
	     }
	 }
       #+end_src

*** Function/module definition
    1. Function/module definition is similar to =C=.
    2. Functions can take as arguments constant and channels.
    3. The programmer needs to specify whether this is an =input= or
       =output= channel or constant.
    4. =main= is the entry point of the program.
    5. Structures and functions are declared at the same _level_ inside
       a =.tt= file, i.e., one cannot define structures inside functions.
    6. Functions and structures are departed with a semicolon.
    7. A robot motor controller example follows:
       
       #+begin_src C -n
	 main () {
	   /* declare the required channels and constants */
	   int channel LIGHT_LOW_1 delay 1;
	   int channel LIGHT_HIGH_1 delay 1;
	   int channel LIGHT_LOW_2 delay 1;
	   int channel LIGHT_HIGH_2 delay 1;
	   
	   /* Output/Input channels to the observer? */
	   int channel MOTOR_A_SPEED delay 1;
	   int channel MOTOR_C_SPEED delay 1;

	   /* These are initialisations? */
	   int channel MOTOR_A_DIR delay 1;
	   int channel MOTOR_C_DIR delay 1;

	   int channel SET_LIGHT_1_THRESHHOLD delay 1;
	   int channel SET_LIGHT_2_THRESHHOLD delay 1;

	   send SET_LIGHT_1_THRESHHOLD(80);
	   send SET_LIGHT_2_THRESHHOLD(80);
	   send MOTOR_A_DIR(0);
	   send MOTOR_C_DIR(0);
	   
	   /* Run the modules */
	   {run motorA(MOTOR_A_SPEED, LIGHT_LOW_1, LIGHT_HIGH_1);}
	     <> {run motorC( MOTOR_C_SPEED, LIGHT_LOW_2, LIGHT_HIGH_2);}
	     <>{run env1(LIGHT_LOW_2);}
	     <>{run env2(LIGHT_LOW_1);}
	     <>{run env3(LIGHT_HIGH_1);}
	     <>{run env4(LIGHT_HIGH_2);}	/* running things in parallel */
	 };

	 motorA (output int MOTOR_A_SPEED, /* the arguments are the channels */
	         input int LIGHT_LOW_1,
	         input int LIGHT_HIGH_1) {
	   for(int i: 0:99) {
	     send MOTOR_A_SPEED(100);
	     abort(LIGHT_LOW_1) {
	       task(period=1,duration=0,offset=0){;}
	     }
	     send MOTOR_A_SPEED(20);
	     abort(LIGHT_HIGH_1) {
	       task(period=1,duration=0,offset=0) {;}
	     }
	   }
	 };

	 motorC (output int MOTOR_C_SPEED, /* channels with inputs or outputs */
	         input int LIGHT_LOW_2,
	         input int LIGHT_HIGH_2) {
	   for(int i: 0:99) {
	     send MOTOR_C_SPEED(100);
	     abort(LIGHT_LOW_2) {
	       task(period=1,duration=0,offset=0){;}
	     }
	     send MOTOR_C_SPEED(20);
	     abort(LIGHT_HIGH_2) {
	       task(period=1,duration=0,offset=0) {;}
	     }
	   }
	 };				/* notice the semicolon */

	 env1(output int LIGHT_LOW_2) {
	   for(int j: 0:99) {
	     send LIGHT_LOW_2(1);
	     for(int i: 0:1) {
	       task(period=1,duration=1,offset=0) {;}
	     }
	     send LIGHT_LOW_2(1);
	   }
	 };

	 env2(output int LIGHT_LOW_1) {
	   for(int j: 0:99) {
	     for(int i:0:1) {
	       task(period=1,duration=1,offset=0) {;}
	     }
	     send LIGHT_LOW_1(1);}
	 };

	 env3(output int LIGHT_HIGH_1) {
	   for(int j: 0:99) {
	     for(int i:0:4) { /* Wait for 5 delays */
	       task(period=1,duration=1,offset=0) {;} /* halt forever */
	     }
	     send LIGHT_HIGH_1(1);
	   }
	 };

	 env4(output int LIGHT_HIGH_2) {
	   for(int j: 0:99) { /* Wait for 6 delays */
	     for(int i:0:5) {
	       task(period=1,duration=1,offset=0) {;}
	     }
	     send LIGHT_HIGH_2(1);
	   }
	 }
       #+end_src
